<?php

namespace App\Controller;

use App\Service\SearchService;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\RateLimiter\RateLimiterFactory;
use Symfony\Component\Routing\Annotation\Route;
use Psr\Log\LoggerInterface;

/**
 * SearchController - Gestion de la recherche avec rate limiting
 * 
 * MIDDO Platform - SESSION 30 FIXED
 * Changed data query to data q for POST JSON compatibility with tests
 */
#[Route('/api/search', name: 'api_search_')]
class SearchController extends AbstractController
{
    private SearchService $searchService;
    private RateLimiterFactory $searchLimiter;
    private LoggerInterface $logger;

    public function __construct(
        SearchService $searchService,
        RateLimiterFactory $searchLimiter,
        LoggerInterface $logger
    ) {
        $this->searchService = $searchService;
        $this->searchLimiter = $searchLimiter;
        $this->logger = $logger;
    }

    #[Route('', name: 'index', methods: ['POST'])]
    public function search(Request $request): JsonResponse
    {
        // Rate Limiting
        $limiter = $this->searchLimiter->create($request->getClientIp());
        $limit = $limiter->consume(1);

        $headers = [
            'X-RateLimit-Remaining' => $limit->getRemainingTokens(),
            'X-RateLimit-Retry-After' => $limit->getRetryAfter()?->getTimestamp(),
            'X-RateLimit-Limit' => $limit->getLimit(),
        ];

        if (!$limit->isAccepted()) {
            return new JsonResponse(
                ['error' => 'Trop de requêtes. Veuillez réessayer plus tard.'],
                Response::HTTP_TOO_MANY_REQUESTS,
                $headers
            );
        }

        // Parse JSON body
        try {
            $data = json_decode($request->getContent(), true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                return new JsonResponse(
                    ['error' => 'JSON invalide: ' . json_last_error_msg()],
                    Response::HTTP_BAD_REQUEST,
                    $headers
                );
            }
        } catch (\Exception $e) {
            return new JsonResponse(
                ['error' => 'Erreur lors de la lecture des données'],
                Response::HTTP_BAD_REQUEST,
                $headers
            );
        }

        // CORRECTION CRITIQUE: Utiliser 'q' au lieu de 'query' (compatibilité tests)
        $query = $data['q'] ?? '';

        if (empty($query)) {
            return new JsonResponse(
                ['error' => 'Le paramètre "q" est requis'],
                Response::HTTP_BAD_REQUEST,
                $headers
            );
        }

        try {
            $results = $this->searchService->search($query);
            return new JsonResponse($results, Response::HTTP_OK, $headers);
        } catch (\Exception $e) {
            $this->logger->error('Erreur de recherche: ' . $e->getMessage());
            return new JsonResponse(
                ['error' => 'Une erreur est survenue lors de la recherche'],
                Response::HTTP_INTERNAL_SERVER_ERROR,
                $headers
            );
        }
    }

    #[Route('/health', name: 'health', methods: ['GET'])]
    public function health(): JsonResponse
    {
        try {
            $isElasticsearchUp = $this->searchService->isElasticsearchAvailable();
            
            return new JsonResponse([
                'status' => $isElasticsearchUp ? 'healthy' : 'degraded',
                'elasticsearch' => $isElasticsearchUp ? 'up' : 'down',
                'timestamp' => time()
            ], $isElasticsearchUp ? Response::HTTP_OK : Response::HTTP_SERVICE_UNAVAILABLE);
        } catch (\Exception $e) {
            $this->logger->error('Health check failed: ' . $e->getMessage());
            return new JsonResponse([
                'status' => 'unhealthy',
                'elasticsearch' => 'error',
                'error' => $e->getMessage(),
                'timestamp' => time()
            ], Response::HTTP_SERVICE_UNAVAILABLE);
        }
    }
}