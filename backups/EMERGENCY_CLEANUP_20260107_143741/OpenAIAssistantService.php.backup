<?php

namespace App\Service;

use App\Entity\AIInteraction;
use App\Repository\AIInteractionRepository;
use Doctrine\ORM\EntityManagerInterface;
use OpenAI;

class OpenAIAssistantService implements AIAssistantInterface
{
    private $client;
    private $entityManager;
    private $aiInteractionRepository;
    private string $model;

    public function __construct(
        string $openaiApiKey,
        string $openaiModel,
        EntityManagerInterface $entityManager,
        AIInteractionRepository $aiInteractionRepository
    ) {
        $this->client = OpenAI::client($openaiApiKey);
        $this->model = $openaiModel;
        $this->entityManager = $entityManager;
        $this->aiInteractionRepository = $aiInteractionRepository;
    }

    public function generateResponse(string $prompt, ?array $context = null): string
    {
        $messages = [
            ['role' => 'system', 'content' => 'Tu es un assistant IA pour MIDDO, une plateforme de networking professionnel. Tu aides les utilisateurs à créer et gérer leurs projets collaboratifs.'],
            ['role' => 'user', 'content' => $prompt]
        ];

        // Ajoute le contexte si fourni
        if ($context) {
            $contextString = json_encode($context, JSON_UNESCAPED_UNICODE);
            $messages[0]['content'] .= "\n\nContexte : " . $contextString;
        }

        try {
            $response = $this->client->chat()->create([
                'model' => $this->model,
                'messages' => $messages,
                'max_tokens' => 500,
                'temperature' => 0.7,
            ]);

            $aiResponse = $response->choices[0]->message->content;

            // Log l'interaction
            $this->logInteraction('chat', $prompt, $aiResponse, $context);

            return $aiResponse;

        } catch (\Exception $e) {
            return "Désolé, une erreur s'est produite : " . $e->getMessage();
        }
    }

    public function suggestProjectImprovements(string $projectDescription, array $projectData): array
    {
        $prompt = "Analyse cette description de projet et suggère 3 améliorations concrètes :\n\n";
        $prompt .= "Titre : " . ($projectData['title'] ?? 'Non défini') . "\n";
        $prompt .= "Description : " . $projectDescription . "\n";
        $prompt .= "Catégorie : " . ($projectData['category'] ?? 'Non définie') . "\n\n";
        $prompt .= "Format attendu : Réponds avec exactement 3 suggestions numérotées, chacune sur une ligne commençant par un chiffre.";

        try {
            $response = $this->client->chat()->create([
                'model' => $this->model,
                'messages' => [
                    ['role' => 'system', 'content' => 'Tu es un expert en gestion de projets collaboratifs. Donne des conseils précis et actionnables.'],
                    ['role' => 'user', 'content' => $prompt]
                ],
                'max_tokens' => 400,
                'temperature' => 0.8,
            ]);

            $aiResponse = $response->choices[0]->message->content;

            // Parse les suggestions
            $suggestions = [];
            $lines = explode("\n", $aiResponse);
            foreach ($lines as $line) {
                $line = trim($line);
                if (preg_match('/^\d+[\.\)]\s*(.+)$/', $line, $matches)) {
                    $suggestions[] = $matches[1];
                }
            }

            // Log l'interaction
            $this->logInteraction('project_improvement', $prompt, $aiResponse, $projectData);

            return array_slice($suggestions, 0, 3); // Max 3 suggestions

        } catch (\Exception $e) {
            return ["Erreur : " . $e->getMessage()];
        }
    }

    public function matchUsersToProject(array $projectData, array $availableUsers): array
    {
        $prompt = "Voici un projet :\n";
        $prompt .= "Titre : " . ($projectData['title'] ?? 'Non défini') . "\n";
        $prompt .= "Compétences requises : " . ($projectData['skills'] ?? 'Non défini') . "\n";
        $prompt .= "Localisation : " . ($projectData['location'] ?? 'Non définie') . "\n\n";
        
        $prompt .= "Voici les utilisateurs disponibles (ID - Compétences - Localisation) :\n";
        foreach ($availableUsers as $user) {
            $prompt .= "- ID " . $user['id'] . " : " . ($user['skills'] ?? '') . " | " . ($user['location'] ?? '') . "\n";
        }
        
        $prompt .= "\nDonne-moi les 5 meilleurs matchs sous forme : ID utilisateur suivi d'un score de 0 à 100. Format : 'ID:score'";

        try {
            $response = $this->client->chat()->create([
                'model' => $this->model,
                'messages' => [
                    ['role' => 'system', 'content' => 'Tu es un expert en matching de profils professionnels. Analyse les compétences et localisations pour proposer les meilleurs matchs.'],
                    ['role' => 'user', 'content' => $prompt]
                ],
                'max_tokens' => 300,
                'temperature' => 0.5,
            ]);

            $aiResponse = $response->choices[0]->message->content;

            // Parse les matchs
            $matches = [];
            preg_match_all('/(\d+):(\d+)/', $aiResponse, $found);
            
            if (isset($found[1]) && isset($found[2])) {
                for ($i = 0; $i < min(5, count($found[1])); $i++) {
                    $matches[] = [
                        'user_id' => (int)$found[1][$i],
                        'score' => (int)$found[2][$i]
                    ];
                }
            }

            // Log l'interaction
            $this->logInteraction('user_matching', $prompt, $aiResponse, ['project' => $projectData, 'users_count' => count($availableUsers)]);

            return $matches;

        } catch (\Exception $e) {
            return [];
        }
    }

    public function analyzeSentiment(string $text): array
    {
        $prompt = "Analyse le sentiment de ce texte et réponds UNIQUEMENT avec un JSON valide contenant 'sentiment' (positif/neutre/négatif) et 'confidence' (0-100) :\n\n" . $text;

        try {
            $response = $this->client->chat()->create([
                'model' => $this->model,
                'messages' => [
                    ['role' => 'system', 'content' => 'Tu es un analyseur de sentiment. Réponds UNIQUEMENT avec un objet JSON valide, rien d\'autre.'],
                    ['role' => 'user', 'content' => $prompt]
                ],
                'max_tokens' => 100,
                'temperature' => 0.3,
            ]);

            $aiResponse = trim($response->choices[0]->message->content);

            // Nettoie la réponse (enlève les markdown code blocks si présents)
            $aiResponse = preg_replace('/```json\s*|\s*```/', '', $aiResponse);
            
            $result = json_decode($aiResponse, true);

            if (!$result || !isset($result['sentiment'])) {
                $result = ['sentiment' => 'neutre', 'confidence' => 50];
            }

            // Log l'interaction
            $this->logInteraction('sentiment_analysis', $prompt, $aiResponse, ['text_length' => strlen($text)]);

            return $result;

        } catch (\Exception $e) {
            return ['sentiment' => 'neutre', 'confidence' => 0, 'error' => $e->getMessage()];
        }
    }

    private function logInteraction(string $type, string $prompt, string $response, ?array $metadata = null): void
    {
        try {
            $interaction = new AIInteraction();
            $interaction->setInteractionType($type);
            $interaction->setPrompt($prompt);
            $interaction->setResponse($response);
            $interaction->setModel($this->model);
            $interaction->setTokensUsed($this->estimateTokens($prompt . $response));
            
            if ($metadata) {
                $interaction->setMetadata($metadata);
            }

            $this->entityManager->persist($interaction);
            $this->entityManager->flush();
        } catch (\Exception $e) {
            // Log silencieux en cas d'erreur (ne bloque pas le flux principal)
        }
    }

    private function estimateTokens(string $text): int
    {
        // Estimation approximative : 1 token ≈ 4 caractères
        return (int)ceil(strlen($text) / 4);
    }
}
